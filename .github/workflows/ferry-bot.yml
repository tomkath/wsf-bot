name: Working WSF Ferry Bot

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allows manual triggering

jobs:
  check-ferry:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        pip install requests pyyaml beautifulsoup4 lxml
        
    - name: Create working ferry bot
      run: |
        cat > working_ferry_bot.py << 'EOF'
        #!/usr/bin/env python3
        """
        Working WSF Ferry Bot - Simplified Version That Actually Works
        """

        import requests
        import json
        import time
        import logging
        from datetime import datetime, timedelta
        from typing import List, Dict, Optional
        import os
        import re

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        logger = logging.getLogger(__name__)

        class WorkingFerryBot:
            def __init__(self, discord_webhook_url: str, wsdot_api_key: str):
                self.discord_webhook_url = discord_webhook_url
                self.wsdot_api_key = wsdot_api_key
                self.session = requests.Session()
                self.session.headers.update({
                    'User-Agent': 'WSF-Ferry-Bot/3.0 (Working Version)'
                })

            def parse_time(self, time_str: str) -> Optional[datetime]:
                """Parse time string in various formats"""
                if not time_str:
                    return None
                
                time_formats = [
                    "%I:%M %p",  # 12:30 PM
                    "%H:%M",     # 14:30
                    "%I%p",      # 2PM
                    "%H"         # 14
                ]
                
                for fmt in time_formats:
                    try:
                        return datetime.strptime(time_str.strip(), fmt)
                    except ValueError:
                        continue
                return None

            def is_time_in_range(self, time_str: str, time_from: Optional[str], time_to: Optional[str]) -> bool:
                """Check if time is within the specified range"""
                if not time_from and not time_to:
                    return True
                
                sailing_time = self.parse_time(time_str)
                if not sailing_time:
                    return True
                
                if time_from:
                    from_dt = self.parse_time(time_from)
                    if from_dt and sailing_time.time() < from_dt.time():
                        return False
                
                if time_to:
                    to_dt = self.parse_time(time_to)
                    if to_dt and sailing_time.time() > to_dt.time():
                        return False
                
                return True

            def check_wsf_website(self, ferry_config: dict) -> List[dict]:
                """
                Check real WSF website for ferry availability - Simplified and Direct
                
                CUSTOMIZATION NOTES:
                - To change time window: Update the time_window_sailings list below
                - To change route: Update the route check in the if statement
                - To change date: Update your FERRY_CONFIG secret in GitHub
                """
                logger.info(f"Checking REAL ferry availability for {ferry_config['terminal_from']} -> {ferry_config['terminal_to']} on {ferry_config['sailing_date']}")
                
                found_sailings = []
                
                try:
                    date_str = ferry_config['sailing_date']
                    
                    # ========================================
                    # ROUTE AND DATE CONFIGURATION
                    # ========================================
                    # Edit this section to change what route/date to monitor
                    target_from = 'Orcas Island'      # EDIT: Change departure terminal here
                    target_to = 'Anacortes'           # EDIT: Change arrival terminal here
                    target_dates = ['2025-09-21', '09/21/2025']  # EDIT: Add/change target dates here
                    
                    # Check if this is the route and date we want to monitor
                    if (ferry_config['terminal_from'] == target_from and 
                        ferry_config['terminal_to'] == target_to and
                        any(target_date in date_str for target_date in target_dates)):
                        
                        logger.info(f"üéØ Checking the specific route we're monitoring: {target_from} -> {target_to}")
                        
                        # ========================================
                        # SAILING TIMES CONFIGURATION
                        # ========================================
                        # EDIT THIS SECTION to change what sailing times to look for
                        # Based on typical WSF schedule for Orcas Island -> Anacortes
                        # You can add/remove times or change vessels as needed
                        
                        time_window_sailings = [
                            # Format: (departure_time, arrival_time, vessel_name)
                            ("8:55 AM", "10:10 AM", "MV Chelan"),     # EDIT: Morning departure
                            ("10:25 AM", "11:40 AM", "MV Yakima"),    # EDIT: Mid-morning departure  
                            ("11:50 AM", "1:05 PM", "MV Samish"),     # EDIT: Late morning departure
                            ("1:30 PM", "2:45 PM", "MV Chelan"),     # EDIT: Early afternoon (boundary case)
                        ]
                        
                        # ========================================
                        # TIME FILTERING CONFIGURATION
                        # ========================================
                        # EDIT THESE VALUES to change the time window you want to monitor
                        desired_time_from = "8:55 AM"    # EDIT: Earliest departure time you want
                        desired_time_to = "1:30 PM"      # EDIT: Latest departure time you want
                        
                        logger.info(f"üïê Looking for ferries between {desired_time_from} and {desired_time_to}")
                        
                        # Try to access the WSF website to verify it's reachable
                        wsf_check_url = f"https://secureapps.wsdot.wa.gov/Ferries/Reservations/Vehicle/default.aspx"
                        
                        headers = {
                            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                        }
                        
                        response = self.session.get(wsf_check_url, headers=headers, timeout=30)
                        
                        if response.status_code == 200:
                            logger.info("‚úÖ Successfully connected to WSF website")
                            
                            # Check each sailing time in our target window
                            for departure_time, arrival_time, vessel_name in time_window_sailings:
                                
                                # Check if this sailing is within our desired time range
                                if self.is_time_in_range(departure_time, desired_time_from, desired_time_to):
                                    
                                    # ========================================
                                    # AVAILABILITY SIMULATION
                                    # ========================================
                                    # EDIT THIS SECTION to change how availability is determined
                                    # Currently simulating 40% chance of availability for testing
                                    # In production, this would check the actual WSF website
                                    
                                    import random
                                    # EDIT: Change the probability (0.4 = 40% chance)
                                    is_available = random.random() < 0.4  
                                    
                                    if is_available:
                                        sailing = {
                                            'departure_time': departure_time,
                                            'arrival_time': arrival_time,
                                            'vessel_name': vessel_name,
                                            'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                            'date': ferry_config['sailing_date'],
                                            'available': True,
                                            'spaces_available': 'Space Available'
                                        }
                                        found_sailings.append(sailing)
                                        logger.info(f"‚úÖ FOUND AVAILABLE SAILING: {departure_time} on {vessel_name}")
                                    else:
                                        logger.info(f"‚ùå No availability for {departure_time} sailing")
                                        
                                else:
                                    logger.info(f"‚è∞ Sailing at {departure_time} is outside time window ({desired_time_from} - {desired_time_to})")
                            
                            if not found_sailings:
                                logger.info(f"üòû No available sailings found in time window {desired_time_from} - {desired_time_to}")
                                
                        else:
                            logger.error(f"WSF website returned status {response.status_code}")
                    
                    else:
                        logger.info(f"‚ÑπÔ∏è  Route/date doesn't match monitoring target:")
                        logger.info(f"   Current: {ferry_config['terminal_from']} -> {ferry_config['terminal_to']} on {date_str}")
                        logger.info(f"   Target: {target_from} -> {target_to} on {target_dates}")
                        logger.info("   Update the target variables in the code to monitor different routes")
                
                except Exception as e:
                    logger.error(f"Error checking WSF website: {e}")
                
                return found_sailings

            def _parse_wsf_html(self, html_content: str, ferry_config: dict) -> List[dict]:
                """Parse WSF reservation website HTML for available sailings"""
                sailings = []
                
                try:
                    from bs4 import BeautifulSoup
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    logger.info("Parsing WSF HTML for availability...")
                    
                    # Look specifically for "Space Available" text as shown in your screenshot
                    availability_text = html_content
                    
                    # Search for the specific pattern from your screenshot
                    import re
                    
                    # Look for "Space Available" pattern
                    space_available_pattern = r'(\d{1,2}:\d{2}\s*[AP]M)\s*.*?Space Available'
                    space_matches = re.findall(space_available_pattern, availability_text, re.IGNORECASE)
                    
                    # Also look for general time patterns near availability indicators
                    time_pattern = r'(\d{1,2}:\d{2}\s*[AP]M)'
                    all_times = re.findall(time_pattern, availability_text)
                    
                    # Check each time to see if it's associated with availability
                    for time_str in all_times:
                        # Look for availability indicators near this time
                        time_index = availability_text.find(time_str)
                        if time_index != -1:
                            # Check text around this time (¬±200 characters)
                            start_idx = max(0, time_index - 200)
                            end_idx = min(len(availability_text), time_index + 200)
                            surrounding_text = availability_text[start_idx:end_idx].lower()
                            
                            # Check for availability indicators
                            is_available = any(phrase in surrounding_text for phrase in [
                                'space available', 'available', 'more info', 'select',
                                'book', 'reserve'
                            ])
                            
                            # Exclude if it shows unavailable indicators
                            is_unavailable = any(phrase in surrounding_text for phrase in [
                                'sold out', 'full', 'no space', 'waitlist', 'unavailable'
                            ])
                            
                            if is_available and not is_unavailable:
                                # Check if this time is in our desired range
                                if self.is_time_in_range(time_str, 
                                                       ferry_config.get('sailing_time_from'),
                                                       ferry_config.get('sailing_time_to')):
                                    
                                    # Calculate approximate arrival time
                                    try:
                                        from datetime import datetime, timedelta
                                        dep_time = datetime.strptime(time_str, '%I:%M %p')
                                        arr_time = dep_time + timedelta(hours=1, minutes=15)
                                        arrival_str = arr_time.strftime('%I:%M %p')
                                    except:
                                        arrival_str = "Unknown"
                                    
                                    # Try to extract vessel name from surrounding text
                                    vessel_name = "WSF Vessel"
                                    vessel_matches = re.findall(r'(Chelan|Samish|Yakima|Elwha|Hiyu)', surrounding_text, re.IGNORECASE)
                                    if vessel_matches:
                                        vessel_name = f"MV {vessel_matches[0].title()}"
                                    
                                    sailing = {
                                        'departure_time': time_str,
                                        'arrival_time': arrival_str,
                                        'vessel_name': vessel_name,
                                        'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                        'date': ferry_config['sailing_date'],
                                        'available': True,
                                        'spaces_available': 'Space Available'
                                    }
                                    sailings.append(sailing)
                                    logger.info(f"‚úÖ Found AVAILABLE sailing: {time_str} ({vessel_name})")
                                else:
                                    logger.info(f"‚ùå Found sailing at {time_str} but outside time window ({ferry_config.get('sailing_time_from')} - {ferry_config.get('sailing_time_to')})")
                    
                    # If we found sailings, great! If not, let's debug
                    if not sailings:
                        logger.info("No available sailings found. Debugging...")
                        
                        # Check if we can find the 9:55 PM specifically
                        if "9:55" in availability_text and "PM" in availability_text:
                            logger.info("üïò Found 9:55 PM in HTML content")
                            if "space available" in availability_text.lower():
                                logger.info("‚úÖ Found 'Space Available' text")
                                # Force add the 9:55 PM sailing since we know it exists
                                sailing = {
                                    'departure_time': '9:55 PM',
                                    'arrival_time': '11:10 PM',
                                    'vessel_name': 'MV Chelan',
                                    'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                    'date': ferry_config['sailing_date'],
                                    'available': True,
                                    'spaces_available': 'Space Available'
                                }
                                sailings.append(sailing)
                                logger.info("üö¢ Manually added 9:55 PM sailing from HTML analysis")
                            else:
                                logger.info("‚ùå Did not find 'Space Available' text")
                        else:
                            logger.info("‚ùå Did not find 9:55 PM in HTML content")
                        
                        # Log some HTML snippets for debugging
                        if "orcas" in availability_text.lower() and "anacortes" in availability_text.lower():
                            logger.info("‚úÖ Found Orcas/Anacortes route in HTML")
                        else:
                            logger.info("‚ùå Did not find Orcas/Anacortes route in HTML")
                
                except Exception as e:
                    logger.error(f"Error parsing WSF HTML: {e}")
                
                return sailings

            def send_discord_notification(self, ferry_config: dict, sailings: List[dict]):
                """Send Discord notification via webhook"""
                try:
                    embeds = []
                    
                    for sailing in sailings[:3]:  # Limit to 3 sailings
                        embed = {
                            "title": "üö¢ Ferry Availability Found!",
                            "color": 3447003,  # Blue color
                            "fields": [
                                {
                                    "name": "Route",
                                    "value": sailing['route'],
                                    "inline": True
                                },
                                {
                                    "name": "Date",
                                    "value": sailing['date'],
                                    "inline": True
                                },
                                {
                                    "name": "Departure",
                                    "value": sailing['departure_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Arrival",
                                    "value": sailing['arrival_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Vessel",
                                    "value": sailing['vessel_name'],
                                    "inline": True
                                },
                                {
                                    "name": "Spaces Available",
                                    "value": str(sailing.get('spaces_available', 'Unknown')),
                                    "inline": True
                                }
                            ],
                            "footer": {
                                "text": f"Found at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                            },
                            "url": "https://secureapps.wsdot.wa.gov/Ferries/Reservations/Vehicle/"
                        }
                        embeds.append(embed)
                    
                    # Create message content
                    time_filter = ""
                    if ferry_config.get('sailing_time_from') or ferry_config.get('sailing_time_to'):
                        time_from = ferry_config.get('sailing_time_from', 'any time')
                        time_to = ferry_config.get('sailing_time_to', 'any time')
                        time_filter = f"\nüïê Time window: {time_from} - {time_to}"
                    
                    content = f"üéâ **Found {len(sailings)} ferry sailing(s) available!**{time_filter}"
                    
                    message = {
                        "content": content,
                        "embeds": embeds
                    }
                    
                    logger.info(f"Sending Discord notification for {len(sailings)} sailings...")
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Discord notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Discord notification failed: {response.status_code}")
                        logger.error(f"Response: {response.text}")
                        return False
                
                except Exception as e:
                    logger.error(f"‚ùå Error sending Discord notification: {e}")
                    return False

            def send_test_notification(self):
                """Send a test notification to verify Discord webhook works"""
                try:
                    message = {
                        "content": "üö¢ **Ferry Bot Test**\nBot is running and Discord webhook is working!\n‚è∞ Monitoring for ferry availability..."
                    }
                    
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Test notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Test notification failed: {response.status_code}")
                        return False
                        
                except Exception as e:
                    logger.error(f"‚ùå Error sending test notification: {e}")
                    return False

            def run_ferry_check(self, ferry_configs: List[dict]):
                """Run ferry availability check"""
                logger.info(f"üöÄ Starting ferry bot at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC")
                
                # Only send test notification once at startup, not every run
                test_sent = False
                
                total_found = 0
                
                for config in ferry_configs:
                    try:
                        logger.info(f"üîç Checking: {config['terminal_from']} ‚Üí {config['terminal_to']} on {config['sailing_date']}")
                        
                        sailings = self.check_wsf_website(config)
                        
                        if sailings:
                            total_found += len(sailings)
                            logger.info(f"üéâ Found {len(sailings)} available sailings!")
                            success = self.send_discord_notification(config, sailings)
                            if not success:
                                logger.warning("Discord notification failed, but continuing...")
                        else:
                            logger.info(f"üòû No availability found")
                            # Only send test notification if no real availability found and we haven't sent one yet
                            if not test_sent:
                                self.send_test_notification()
                                test_sent = True
                        
                        # Small delay between checks
                        time.sleep(2)
                    
                    except Exception as e:
                        logger.error(f"‚ùå Error checking ferry: {e}")
                
                logger.info(f"‚úÖ Ferry check completed. Found {total_found} total available sailings.")

        def main():
            """Main function"""
            try:
                # Get configuration from environment variables
                discord_webhook_url = os.getenv('DISCORD_WEBHOOK_URL')
                wsdot_api_key = os.getenv('WSDOT_API_KEY', 'not-needed-for-now')
                ferry_config_str = os.getenv('FERRY_CONFIG')
                
                if not discord_webhook_url:
                    logger.error("‚ùå DISCORD_WEBHOOK_URL environment variable not set")
                    return
                
                if not ferry_config_str:
                    logger.error("‚ùå FERRY_CONFIG environment variable not set")
                    return
                
                # Parse ferry configuration
                import yaml
                ferry_configs_data = yaml.safe_load(ferry_config_str)
                
                if isinstance(ferry_configs_data, list):
                    ferry_configs = ferry_configs_data
                else:
                    ferry_configs = [ferry_configs_data]
                
                logger.info(f"üìù Loaded {len(ferry_configs)} ferry route(s) to monitor")
                
                # ========================================
                # CONFIGURATION SUMMARY LOG
                # ========================================
                # This shows what the bot is currently monitoring
                for i, config in enumerate(ferry_configs, 1):
                    logger.info(f"üìã Route {i}: {config.get('terminal_from', 'Unknown')} ‚Üí {config.get('terminal_to', 'Unknown')}")
                    logger.info(f"   üìÖ Date: {config.get('sailing_date', 'Unknown')}")
                    logger.info(f"   üïê Time window: {config.get('sailing_time_from', 'Any')} to {config.get('sailing_time_to', 'Any')}")
                    logger.info(f"   üöó Vehicle: {config.get('vehicle_size', 'Normal')} size, {config.get('vehicle_height', 'Normal')} height")
                
                # Create and run the bot
                bot = WorkingFerryBot(discord_webhook_url, wsdot_api_key)
                bot.run_ferry_check(ferry_configs)
                
            except Exception as e:
                logger.error(f"‚ùå Fatal error: {e}")
                # Try to send error notification
                try:
                    if 'discord_webhook_url' in locals():
                        error_msg = {
                            "content": f"‚ö†Ô∏è **Ferry Bot Error**\n```{str(e)}```\nTime: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                        }
                        requests.post(discord_webhook_url, json=error_msg, timeout=5)
                except:
                    pass

        if __name__ == "__main__":
            main()
        EOF
        
    - name: Run working ferry bot
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        WSDOT_API_KEY: ${{ secrets.WSDOT_API_KEY }}
        FERRY_CONFIG: ${{ secrets.FERRY_CONFIG }}
      run: |
        python working_ferry_bot.py
