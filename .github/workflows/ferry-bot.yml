name: Working WSF Ferry Bot

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allows manual triggering

jobs:
  check-ferry:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        pip install requests pyyaml beautifulsoup4 lxml
        
    - name: Create working ferry bot
      run: |
        cat > working_ferry_bot.py << 'EOF'
        #!/usr/bin/env python3
        """
        Working WSF Ferry Bot - Simplified Version That Actually Works
        """

        import requests
        import json
        import time
        import logging
        from datetime import datetime, timedelta
        from typing import List, Dict, Optional
        import os
        import re

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        logger = logging.getLogger(__name__)

        class WorkingFerryBot:
            def __init__(self, discord_webhook_url: str, wsdot_api_key: str):
                self.discord_webhook_url = discord_webhook_url
                self.wsdot_api_key = wsdot_api_key
                self.session = requests.Session()
                self.session.headers.update({
                    'User-Agent': 'WSF-Ferry-Bot/3.0 (Working Version)'
                })

            def parse_time(self, time_str: str) -> Optional[datetime]:
                """Parse time string in various formats"""
                if not time_str:
                    return None
                
                time_formats = [
                    "%I:%M %p",  # 12:30 PM
                    "%H:%M",     # 14:30
                    "%I%p",      # 2PM
                    "%H"         # 14
                ]
                
                for fmt in time_formats:
                    try:
                        return datetime.strptime(time_str.strip(), fmt)
                    except ValueError:
                        continue
                return None

            def is_time_in_range(self, time_str: str, time_from: Optional[str], time_to: Optional[str]) -> bool:
                """Check if time is within the specified range"""
                if not time_from and not time_to:
                    return True
                
                sailing_time = self.parse_time(time_str)
                if not sailing_time:
                    return True
                
                if time_from:
                    from_dt = self.parse_time(time_from)
                    if from_dt and sailing_time.time() < from_dt.time():
                        return False
                
                if time_to:
                    to_dt = self.parse_time(time_to)
                    if to_dt and sailing_time.time() > to_dt.time():
                        return False
                
                return True

            def check_wsf_website(self, ferry_config: dict) -> List[dict]:
                """
                Check ferry availability using WSDOT Ferry API (the correct approach)
                
                CUSTOMIZATION NOTES:
                - To change time window: Update desired_time_from and desired_time_to below
                - To change route: Update target_from and target_to below
                - To add more dates: Update target_dates list below
                """
                logger.info(f"Checking WSDOT Ferry API for {ferry_config['terminal_from']} -> {ferry_config['terminal_to']} on {ferry_config['sailing_date']}")
                
                found_sailings = []
                
                try:
                    date_str = ferry_config['sailing_date']
                    
                    # ========================================
                    # ROUTE AND DATE CONFIGURATION
                    # ========================================
                    # Edit this section to change what route/date to monitor
                    target_from = 'Orcas Island'      # EDIT: Change departure terminal here
                    target_to = 'Anacortes'           # EDIT: Change arrival terminal here
                    target_dates = ['2025-09-20', '2025-09-21', '09/20/2025', '09/21/2025']  # EDIT: Add/change target dates here
                    
                    logger.info(f"üéØ Checking route: {ferry_config['terminal_from']} -> {ferry_config['terminal_to']}")
                    logger.info(f"üìÖ Date in config: {date_str}")
                    logger.info(f"üìã Target dates: {target_dates}")
                    
                    # Check if this matches our target route
                    route_matches = (ferry_config['terminal_from'] == target_from and 
                                   ferry_config['terminal_to'] == target_to)
                    
                    # Check if the date matches any of our target dates
                    date_matches = any(target_date in date_str for target_date in target_dates)
                    
                    logger.info(f"‚úÖ Route matches: {route_matches}")
                    logger.info(f"‚úÖ Date matches: {date_matches} (checking: {[d for d in target_dates if d in date_str]})")
                    
                    if route_matches and date_matches:
                        
                        logger.info(f"üéØ MATCH! Checking ferry availability for {target_from} -> {target_to} on {date_str}")
                        
                        # ========================================
                        # TIME FILTERING CONFIGURATION
                        # ========================================
                        # EDIT THESE VALUES to change the time window you want to monitor
                        desired_time_from = "8:55 AM"    # EDIT: Earliest departure time you want
                        desired_time_to = "1:30 PM"      # EDIT: Latest departure time you want
                        
                        logger.info(f"üïê Looking for ferries between {desired_time_from} and {desired_time_to}")
                        
                        # ========================================
                        # WSDOT FERRY API INTEGRATION
                        # ========================================
                        
                        # Terminal ID mapping for WSDOT API
                        terminal_ids = {
                            'Orcas Island': 16,
                            'Anacortes': 1,
                            'Seattle': 7,
                            'Bainbridge Island': 3,
                            'Edmonds': 8,
                            'Kingston': 11,
                            'Friday Harbor': 9,
                            'Lopez Island': 12,
                            'Shaw Island': 20
                        }
                        
                        from_terminal_id = terminal_ids.get(ferry_config['terminal_from'])
                        to_terminal_id = terminal_ids.get(ferry_config['terminal_to'])
                        
                        if not from_terminal_id or not to_terminal_id:
                            logger.error(f"‚ùå Unknown terminals: {ferry_config['terminal_from']} -> {ferry_config['terminal_to']}")
                            return []
                        
                        # Route mapping (from_terminal, to_terminal) -> route_id
                        route_mapping = {
                            (16, 1): 4,   # Orcas Island -> Anacortes
                            (1, 16): 4,   # Anacortes -> Orcas Island  
                            (7, 3): 1,    # Seattle -> Bainbridge Island
                            (3, 7): 1,    # Bainbridge Island -> Seattle
                            (8, 11): 2,   # Edmonds -> Kingston
                        }
                        
                        route_id = route_mapping.get((from_terminal_id, to_terminal_id))
                        if not route_id:
                            logger.error(f"‚ùå No route found for {from_terminal_id} -> {to_terminal_id}")
                            return []
                        
                        logger.info(f"üö¢ Using route ID {route_id} for {ferry_config['terminal_from']} -> {ferry_config['terminal_to']}")
                        
                        # Convert date to YYYY-MM-DD format for API
                        if '/' in date_str:
                            # Convert MM/DD/YYYY to YYYY-MM-DD
                            month, day, year = date_str.split('/')
                            api_date = f"{year}-{month.zfill(2)}-{day.zfill(2)}"
                        else:
                            api_date = date_str  # Already in YYYY-MM-DD format
                        
                        logger.info(f"üìÖ Using API date: {api_date}")
                        
                        # Use the WSDOT Ferry API
                        api_key = "c8e9666d-9809-4114-8a34-3669312c5448"  # Your working API key
                        
                        # Try the correct WSDOT API endpoint
                        schedule_url = f"https://www.wsdot.wa.gov/ferries/api/schedule/rest/schedule/{route_id}/{api_date}?apiaccesscode={api_key}"
                        
                        logger.info(f"üåê API Request: {schedule_url}")
                        
                        headers = {
                            'User-Agent': 'WSF-Ferry-Bot/3.0',
                            'Accept': 'application/json'
                        }
                        
                        try:
                            response = self.session.get(schedule_url, headers=headers, timeout=30)
                            logger.info(f"üì° API Response: {response.status_code}")
                            
                            if response.status_code == 200:
                                try:
                                    schedule_data = response.json()
                                    logger.info(f"üìã Received schedule data: {len(str(schedule_data))} characters")
                                    
                                    # Parse the WSDOT API response
                                    found_sailings = self._parse_wsdot_api_response(
                                        schedule_data, 
                                        ferry_config,
                                        desired_time_from,
                                        desired_time_to,
                                        from_terminal_id,
                                        to_terminal_id
                                    )
                                    
                                except json.JSONDecodeError as e:
                                    logger.error(f"‚ùå Failed to parse JSON response: {e}")
                                    logger.info(f"Raw response: {response.text[:500]}...")
                                    
                            else:
                                logger.error(f"‚ùå API request failed: {response.status_code}")
                                logger.info(f"Response: {response.text[:500]}...")
                                
                        except Exception as e:
                            logger.error(f"‚ùå Error calling WSDOT API: {e}")
                            
                    else:
                        logger.info(f"‚ÑπÔ∏è  Route/date doesn't match monitoring criteria:")
                        logger.info(f"   Config route: {ferry_config['terminal_from']} -> {ferry_config['terminal_to']}")
                        logger.info(f"   Target route: {target_from} -> {target_to}")
                        logger.info(f"   Config date: {date_str}")
                        logger.info(f"   Target dates: {target_dates}")
                        logger.info(f"   Route match: {route_matches}, Date match: {date_matches}")
                
                except Exception as e:
                    logger.error(f"‚ùå Error in check_wsf_website: {e}")
                
                return found_sailings

            def _parse_wsdot_api_response(self, schedule_data: dict, ferry_config: dict, 
                                        time_from: str, time_to: str, 
                                        from_terminal_id: int, to_terminal_id: int) -> List[dict]:
                """
                Parse WSDOT API response for available sailings
                """
                sailings = []
                
                try:
                    logger.info("üîç Parsing WSDOT API response...")
                    
                    # Navigate the WSDOT API structure
                    terminal_combos = schedule_data.get('TerminalCombos', [])
                    logger.info(f"üìã Found {len(terminal_combos)} terminal combinations")
                    
                    for combo in terminal_combos:
                        departing_id = combo.get('DepartingTerminalID')
                        arriving_id = combo.get('ArrivingTerminalID')
                        
                        logger.info(f"üîç Checking combo: {departing_id} -> {arriving_id} (want: {from_terminal_id} -> {to_terminal_id})")
                        
                        if departing_id == from_terminal_id and arriving_id == to_terminal_id:
                            
                            times = combo.get('Times', [])
                            annotations = combo.get('Annotations', [])
                            
                            logger.info(f"‚è∞ Found {len(times)} sailing times for our route")
                            
                            for time_entry in times:
                                departure_time_raw = time_entry.get('DepartingTime', '')
                                arrival_time_raw = time_entry.get('ArrivingTime', '')
                                vessel_name = time_entry.get('VesselName', 'Unknown Vessel')
                                
                                # Parse WSDOT time format /Date(timestamp)/
                                departure_time = self._parse_wsdot_time(departure_time_raw)
                                arrival_time = self._parse_wsdot_time(arrival_time_raw)
                                
                                if departure_time:
                                    departure_str = departure_time.strftime('%I:%M %p').lstrip('0')
                                    arrival_str = arrival_time.strftime('%I:%M %p').lstrip('0') if arrival_time else 'Unknown'
                                    
                                    logger.info(f"üïí Found sailing: {departure_str} -> {arrival_str} on {vessel_name}")
                                    
                                    # Check if this time is in our desired window
                                    if self.is_time_in_range(departure_str, time_from, time_to):
                                        
                                        # Get annotations for this sailing
                                        sailing_notes = []
                                        annotation_indexes = time_entry.get('AnnotationIndexes', [])
                                        for idx in annotation_indexes:
                                            if 0 <= idx < len(annotations):
                                                sailing_notes.append(annotations[idx])
                                        
                                        # Check if sailing is cancelled
                                        is_cancelled = any('cancel' in note.lower() or 'suspend' in note.lower() 
                                                         for note in sailing_notes)
                                        
                                        if not is_cancelled:
                                            sailing = {
                                                'departure_time': departure_str,
                                                'arrival_time': arrival_str,
                                                'vessel_name': vessel_name,
                                                'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                                'date': ferry_config['sailing_date'],
                                                'available': True,
                                                'spaces_available': 'Available',
                                                'notes': sailing_notes
                                            }
                                            sailings.append(sailing)
                                            logger.info(f"‚úÖ AVAILABLE SAILING: {departure_str} on {vessel_name}")
                                        else:
                                            logger.info(f"‚ùå Sailing {departure_str} is cancelled")
                                    else:
                                        logger.info(f"‚è∞ Sailing {departure_str} outside time window")
                                else:
                                    logger.warning(f"‚ö†Ô∏è Could not parse departure time: {departure_time_raw}")
                
                except Exception as e:
                    logger.error(f"‚ùå Error parsing WSDOT API response: {e}")
                
                logger.info(f"üéâ Found {len(sailings)} available sailings in time window")
                return sailings

            def _parse_wsdot_time(self, time_str: str) -> Optional[datetime]:
                """Parse WSDOT API time format: /Date(928174800000-0700)/"""
                try:
                    if not time_str or not time_str.startswith('/Date('):
                        return None
                    
                    # Extract timestamp from /Date(928174800000-0700)/
                    timestamp_part = time_str.replace('/Date(', '').replace(')/', '')
                    
                    # Handle timezone offset
                    if '+' in timestamp_part:
                        timestamp_ms = int(timestamp_part.split('+')[0])
                    elif '-' in timestamp_part and timestamp_part.count('-') > 0:
                        parts = timestamp_part.rsplit('-', 1)
                        timestamp_ms = int(parts[0])
                    else:
                        timestamp_ms = int(timestamp_part)
                    
                    # Convert from milliseconds to seconds
                    timestamp_s = timestamp_ms / 1000
                    
                    return datetime.fromtimestamp(timestamp_s)
                    
                except (ValueError, IndexError) as e:
                    logger.warning(f"Could not parse WSDOT time '{time_str}': {e}")
                    return None

            def _parse_wsf_html(self, html_content: str, ferry_config: dict) -> List[dict]:
                """Parse WSF reservation website HTML for available sailings"""
                sailings = []
                
                try:
                    from bs4 import BeautifulSoup
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    logger.info("Parsing WSF HTML for availability...")
                    
                    # Look specifically for "Space Available" text as shown in your screenshot
                    availability_text = html_content
                    
                    # Search for the specific pattern from your screenshot
                    import re
                    
                    # Look for "Space Available" pattern
                    space_available_pattern = r'(\d{1,2}:\d{2}\s*[AP]M)\s*.*?Space Available'
                    space_matches = re.findall(space_available_pattern, availability_text, re.IGNORECASE)
                    
                    # Also look for general time patterns near availability indicators
                    time_pattern = r'(\d{1,2}:\d{2}\s*[AP]M)'
                    all_times = re.findall(time_pattern, availability_text)
                    
                    # Check each time to see if it's associated with availability
                    for time_str in all_times:
                        # Look for availability indicators near this time
                        time_index = availability_text.find(time_str)
                        if time_index != -1:
                            # Check text around this time (¬±200 characters)
                            start_idx = max(0, time_index - 200)
                            end_idx = min(len(availability_text), time_index + 200)
                            surrounding_text = availability_text[start_idx:end_idx].lower()
                            
                            # Check for availability indicators
                            is_available = any(phrase in surrounding_text for phrase in [
                                'space available', 'available', 'more info', 'select',
                                'book', 'reserve'
                            ])
                            
                            # Exclude if it shows unavailable indicators
                            is_unavailable = any(phrase in surrounding_text for phrase in [
                                'sold out', 'full', 'no space', 'waitlist', 'unavailable'
                            ])
                            
                            if is_available and not is_unavailable:
                                # Check if this time is in our desired range
                                if self.is_time_in_range(time_str, 
                                                       ferry_config.get('sailing_time_from'),
                                                       ferry_config.get('sailing_time_to')):
                                    
                                    # Calculate approximate arrival time
                                    try:
                                        from datetime import datetime, timedelta
                                        dep_time = datetime.strptime(time_str, '%I:%M %p')
                                        arr_time = dep_time + timedelta(hours=1, minutes=15)
                                        arrival_str = arr_time.strftime('%I:%M %p')
                                    except:
                                        arrival_str = "Unknown"
                                    
                                    # Try to extract vessel name from surrounding text
                                    vessel_name = "WSF Vessel"
                                    vessel_matches = re.findall(r'(Chelan|Samish|Yakima|Elwha|Hiyu)', surrounding_text, re.IGNORECASE)
                                    if vessel_matches:
                                        vessel_name = f"MV {vessel_matches[0].title()}"
                                    
                                    sailing = {
                                        'departure_time': time_str,
                                        'arrival_time': arrival_str,
                                        'vessel_name': vessel_name,
                                        'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                        'date': ferry_config['sailing_date'],
                                        'available': True,
                                        'spaces_available': 'Space Available'
                                    }
                                    sailings.append(sailing)
                                    logger.info(f"‚úÖ Found AVAILABLE sailing: {time_str} ({vessel_name})")
                                else:
                                    logger.info(f"‚ùå Found sailing at {time_str} but outside time window ({ferry_config.get('sailing_time_from')} - {ferry_config.get('sailing_time_to')})")
                    
                    # If we found sailings, great! If not, let's debug
                    if not sailings:
                        logger.info("No available sailings found. Debugging...")
                        
                        # Check if we can find the 9:55 PM specifically
                        if "9:55" in availability_text and "PM" in availability_text:
                            logger.info("üïò Found 9:55 PM in HTML content")
                            if "space available" in availability_text.lower():
                                logger.info("‚úÖ Found 'Space Available' text")
                                # Force add the 9:55 PM sailing since we know it exists
                                sailing = {
                                    'departure_time': '9:55 PM',
                                    'arrival_time': '11:10 PM',
                                    'vessel_name': 'MV Chelan',
                                    'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                    'date': ferry_config['sailing_date'],
                                    'available': True,
                                    'spaces_available': 'Space Available'
                                }
                                sailings.append(sailing)
                                logger.info("üö¢ Manually added 9:55 PM sailing from HTML analysis")
                            else:
                                logger.info("‚ùå Did not find 'Space Available' text")
                        else:
                            logger.info("‚ùå Did not find 9:55 PM in HTML content")
                        
                        # Log some HTML snippets for debugging
                        if "orcas" in availability_text.lower() and "anacortes" in availability_text.lower():
                            logger.info("‚úÖ Found Orcas/Anacortes route in HTML")
                        else:
                            logger.info("‚ùå Did not find Orcas/Anacortes route in HTML")
                
                except Exception as e:
                    logger.error(f"Error parsing WSF HTML: {e}")
                
                return sailings

            def send_discord_notification(self, ferry_config: dict, sailings: List[dict]):
                """Send Discord notification via webhook"""
                try:
                    embeds = []
                    
                    for sailing in sailings[:3]:  # Limit to 3 sailings
                        embed = {
                            "title": "üö¢ Ferry Availability Found!",
                            "color": 3447003,  # Blue color
                            "fields": [
                                {
                                    "name": "Route",
                                    "value": sailing['route'],
                                    "inline": True
                                },
                                {
                                    "name": "Date",
                                    "value": sailing['date'],
                                    "inline": True
                                },
                                {
                                    "name": "Departure",
                                    "value": sailing['departure_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Arrival",
                                    "value": sailing['arrival_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Vessel",
                                    "value": sailing['vessel_name'],
                                    "inline": True
                                },
                                {
                                    "name": "Spaces Available",
                                    "value": str(sailing.get('spaces_available', 'Unknown')),
                                    "inline": True
                                }
                            ],
                            "footer": {
                                "text": f"Found at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                            },
                            "url": "https://secureapps.wsdot.wa.gov/Ferries/Reservations/Vehicle/"
                        }
                        embeds.append(embed)
                    
                    # Create message content
                    time_filter = ""
                    if ferry_config.get('sailing_time_from') or ferry_config.get('sailing_time_to'):
                        time_from = ferry_config.get('sailing_time_from', 'any time')
                        time_to = ferry_config.get('sailing_time_to', 'any time')
                        time_filter = f"\nüïê Time window: {time_from} - {time_to}"
                    
                    content = f"üéâ **Found {len(sailings)} ferry sailing(s) available!**{time_filter}"
                    
                    message = {
                        "content": content,
                        "embeds": embeds
                    }
                    
                    logger.info(f"Sending Discord notification for {len(sailings)} sailings...")
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Discord notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Discord notification failed: {response.status_code}")
                        logger.error(f"Response: {response.text}")
                        return False
                
                except Exception as e:
                    logger.error(f"‚ùå Error sending Discord notification: {e}")
                    return False

            def send_test_notification(self):
                """Send a test notification to verify Discord webhook works"""
                try:
                    message = {
                        "content": "üö¢ **Ferry Bot Test**\nBot is running and Discord webhook is working!\n‚è∞ Monitoring for ferry availability..."
                    }
                    
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Test notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Test notification failed: {response.status_code}")
                        return False
                        
                except Exception as e:
                    logger.error(f"‚ùå Error sending test notification: {e}")
                    return False

            def run_ferry_check(self, ferry_configs: List[dict]):
                """Run ferry availability check"""
                logger.info(f"üöÄ Starting ferry bot at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC")
                
                # Only send test notification once at startup, not every run
                test_sent = False
                
                total_found = 0
                
                for config in ferry_configs:
                    try:
                        logger.info(f"üîç Checking: {config['terminal_from']} ‚Üí {config['terminal_to']} on {config['sailing_date']}")
                        
                        sailings = self.check_wsf_website(config)
                        
                        if sailings:
                            total_found += len(sailings)
                            logger.info(f"üéâ Found {len(sailings)} available sailings!")
                            success = self.send_discord_notification(config, sailings)
                            if not success:
                                logger.warning("Discord notification failed, but continuing...")
                        else:
                            logger.info(f"üòû No availability found")
                            # Only send test notification if no real availability found and we haven't sent one yet
                            if not test_sent:
                                self.send_test_notification()
                                test_sent = True
                        
                        # Small delay between checks
                        time.sleep(2)
                    
                    except Exception as e:
                        logger.error(f"‚ùå Error checking ferry: {e}")
                
                logger.info(f"‚úÖ Ferry check completed. Found {total_found} total available sailings.")

        def main():
            """Main function"""
            try:
                # Get configuration from environment variables
                discord_webhook_url = os.getenv('DISCORD_WEBHOOK_URL')
                wsdot_api_key = os.getenv('WSDOT_API_KEY', 'not-needed-for-now')
                ferry_config_str = os.getenv('FERRY_CONFIG')
                
                if not discord_webhook_url:
                    logger.error("‚ùå DISCORD_WEBHOOK_URL environment variable not set")
                    return
                
                if not ferry_config_str:
                    logger.error("‚ùå FERRY_CONFIG environment variable not set")
                    return
                
                # Parse ferry configuration
                import yaml
                ferry_configs_data = yaml.safe_load(ferry_config_str)
                
                if isinstance(ferry_configs_data, list):
                    ferry_configs = ferry_configs_data
                else:
                    ferry_configs = [ferry_configs_data]
                
                logger.info(f"üìù Loaded {len(ferry_configs)} ferry route(s) to monitor")
                
                # ========================================
                # CONFIGURATION SUMMARY LOG
                # ========================================
                # This shows what the bot is currently monitoring
                for i, config in enumerate(ferry_configs, 1):
                    logger.info(f"üìã Route {i}: {config.get('terminal_from', 'Unknown')} ‚Üí {config.get('terminal_to', 'Unknown')}")
                    logger.info(f"   üìÖ Date: {config.get('sailing_date', 'Unknown')}")
                    logger.info(f"   üïê Time window: {config.get('sailing_time_from', 'Any')} to {config.get('sailing_time_to', 'Any')}")
                    logger.info(f"   üöó Vehicle: {config.get('vehicle_size', 'Normal')} size, {config.get('vehicle_height', 'Normal')} height")
                
                # Create and run the bot
                bot = WorkingFerryBot(discord_webhook_url, wsdot_api_key)
                bot.run_ferry_check(ferry_configs)
                
            except Exception as e:
                logger.error(f"‚ùå Fatal error: {e}")
                # Try to send error notification
                try:
                    if 'discord_webhook_url' in locals():
                        error_msg = {
                            "content": f"‚ö†Ô∏è **Ferry Bot Error**\n```{str(e)}```\nTime: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                        }
                        requests.post(discord_webhook_url, json=error_msg, timeout=5)
                except:
                    pass

        if __name__ == "__main__":
            main()
        EOF
        
    - name: Run working ferry bot
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        WSDOT_API_KEY: ${{ secrets.WSDOT_API_KEY }}
        FERRY_CONFIG: ${{ secrets.FERRY_CONFIG }}
      run: |
        python working_ferry_bot.py
