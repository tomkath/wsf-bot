name: Working WSF Ferry Bot

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allows manual triggering

jobs:
  check-ferry:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Install dependencies
      run: |
        pip install requests pyyaml beautifulsoup4 lxml
        
    - name: Create working ferry bot
      run: |
        cat > working_ferry_bot.py << 'EOF'
        #!/usr/bin/env python3
        """
        Working WSF Ferry Bot - Simplified Version That Actually Works
        """

        import requests
        import json
        import time
        import logging
        from datetime import datetime, timedelta
        from typing import List, Dict, Optional
        import os
        import re

        # Configure logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        logger = logging.getLogger(__name__)

        class WorkingFerryBot:
            def __init__(self, discord_webhook_url: str, wsdot_api_key: str):
                self.discord_webhook_url = discord_webhook_url
                self.wsdot_api_key = wsdot_api_key
                self.session = requests.Session()
                self.session.headers.update({
                    'User-Agent': 'WSF-Ferry-Bot/3.0 (Working Version)'
                })

            def parse_time(self, time_str: str) -> Optional[datetime]:
                """Parse time string in various formats"""
                if not time_str:
                    return None
                
                time_formats = [
                    "%I:%M %p",  # 12:30 PM
                    "%H:%M",     # 14:30
                    "%I%p",      # 2PM
                    "%H"         # 14
                ]
                
                for fmt in time_formats:
                    try:
                        return datetime.strptime(time_str.strip(), fmt)
                    except ValueError:
                        continue
                return None

            def is_time_in_range(self, time_str: str, time_from: Optional[str], time_to: Optional[str]) -> bool:
                """Check if time is within the specified range"""
                if not time_from and not time_to:
                    return True
                
                sailing_time = self.parse_time(time_str)
                if not sailing_time:
                    return True
                
                if time_from:
                    from_dt = self.parse_time(time_from)
                    if from_dt and sailing_time.time() < from_dt.time():
                        return False
                
                if time_to:
                    to_dt = self.parse_time(time_to)
                    if to_dt and sailing_time.time() > to_dt.time():
                        return False
                
                return True

            def check_wsf_website(self, ferry_config: dict) -> List[dict]:
                """
                Check real WSF website for ferry availability
                """
                logger.info(f"Checking REAL ferry availability for {ferry_config['terminal_from']} -> {ferry_config['terminal_to']} on {ferry_config['sailing_date']}")
                
                found_sailings = []
                
                try:
                    # Map terminal names to WSF website codes
                    terminal_codes = {
                        'Anacortes': 'ANA',
                        'Orcas Island': 'ORC', 
                        'Friday Harbor': 'FH',
                        'Lopez Island': 'LOP',
                        'Shaw Island': 'SHA',
                        'Seattle': 'SEA',
                        'Bainbridge Island': 'BI',
                        'Edmonds': 'EDM',
                        'Kingston': 'KING',
                        'Mukilteo': 'MUK',
                        'Clinton': 'CLN'
                    }
                    
                    from_code = terminal_codes.get(ferry_config['terminal_from'])
                    to_code = terminal_codes.get(ferry_config['terminal_to'])
                    
                    if not from_code or not to_code:
                        logger.error(f"Unknown terminals: {ferry_config['terminal_from']} -> {ferry_config['terminal_to']}")
                        return []
                    
                    # Parse the date
                    date_str = ferry_config['sailing_date']
                    if '/' in date_str:
                        # Convert MM/DD/YYYY to YYYY-MM-DD
                        parts = date_str.split('/')
                        formatted_date = f"{parts[2]}-{parts[0].zfill(2)}-{parts[1].zfill(2)}"
                    else:
                        formatted_date = date_str
                    
                    logger.info(f"Checking WSF reservation system for {from_code} -> {to_code} on {formatted_date}")
                    
                    # Check WSF reservation website
                    # This is the actual WSF vehicle reservation system
                    wsf_url = "https://secureapps.wsdot.wa.gov/Ferries/Reservations/Vehicle/VehicleReservationAvailability.aspx"
                    
                    # Prepare form data for WSF reservation check
                    form_data = {
                        'DepartingTerminalID': from_code,
                        'ArrivingTerminalID': to_code,
                        'DepartingDate': formatted_date,
                        'VehicleType': ferry_config.get('vehicle_size', 'Normal'),
                        'VehicleHeight': ferry_config.get('vehicle_height', 'Normal'),
                        'PassengerCount': ferry_config.get('passengers', 2)
                    }
                    
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'Accept-Language': 'en-US,en;q=0.5',
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                    
                    # Make request to WSF reservation system
                    response = self.session.post(wsf_url, data=form_data, headers=headers, timeout=30)
                    
                    if response.status_code == 200:
                        # Parse the HTML response for availability
                        html_content = response.text
                        sailings = self._parse_wsf_html(html_content, ferry_config)
                        found_sailings.extend(sailings)
                        
                        if sailings:
                            logger.info(f"üö¢ Found {len(sailings)} available sailings!")
                        else:
                            logger.info("No availability found in reservation system")
                    else:
                        logger.error(f"WSF website returned status {response.status_code}")
                        
                        # Fallback: Check if this is a future date that might not have reservations open yet
                        from datetime import datetime
                        try:
                            check_date = datetime.strptime(formatted_date, '%Y-%m-%d')
                            today = datetime.now()
                            days_ahead = (check_date - today).days
                            
                            if days_ahead > 90:  # More than 3 months ahead
                                logger.info(f"Date is {days_ahead} days in the future - reservations may not be open yet")
                            elif days_ahead < 0:  # Past date
                                logger.info(f"Date is {abs(days_ahead)} days in the past - no reservations available")
                            else:
                                logger.info(f"Date is {days_ahead} days ahead - checking for current availability")
                        except:
                            pass
                
                except Exception as e:
                    logger.error(f"Error checking WSF website: {e}")
                
                return found_sailings

            def _parse_wsf_html(self, html_content: str, ferry_config: dict) -> List[dict]:
                """Parse WSF reservation website HTML for available sailings"""
                sailings = []
                
                try:
                    from bs4 import BeautifulSoup
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    # Look for availability indicators in the WSF website
                    # This would need to be customized based on actual WSF HTML structure
                    
                    # For now, we'll look for common patterns that indicate availability
                    availability_text = html_content.lower()
                    
                    # Check for positive availability indicators
                    if any(phrase in availability_text for phrase in [
                        'available', 'book now', 'reserve', 'select sailing',
                        'departure time', 'sailing times'
                    ]):
                        
                        # Try to extract sailing times from the HTML
                        # This is a simplified parser - real implementation would be more robust
                        import re
                        time_pattern = r'(\d{1,2}:\d{2}\s*[AP]M)'
                        times = re.findall(time_pattern, html_content.upper())
                        
                        for time_str in times[:5]:  # Limit to first 5 found times
                            # Check if this time is in our desired range
                            if self.is_time_in_range(time_str, 
                                                   ferry_config.get('sailing_time_from'),
                                                   ferry_config.get('sailing_time_to')):
                                
                                # Calculate approximate arrival time (add 1hr 15min for San Juan routes)
                                try:
                                    from datetime import datetime, timedelta
                                    dep_time = datetime.strptime(time_str, '%I:%M %p')
                                    arr_time = dep_time + timedelta(hours=1, minutes=15)
                                    arrival_str = arr_time.strftime('%I:%M %p')
                                except:
                                    arrival_str = "Unknown"
                                
                                sailing = {
                                    'departure_time': time_str,
                                    'arrival_time': arrival_str,
                                    'vessel_name': 'WSF Vessel',
                                    'route': f"{ferry_config['terminal_from']} ‚Üí {ferry_config['terminal_to']}",
                                    'date': ferry_config['sailing_date'],
                                    'available': True,
                                    'spaces_available': 'Available'
                                }
                                sailings.append(sailing)
                                logger.info(f"Found available sailing: {time_str}")
                    
                    # Check for "no availability" messages
                    elif any(phrase in availability_text for phrase in [
                        'no availability', 'sold out', 'no sailings available',
                        'no reservations available'
                    ]):
                        logger.info("WSF website shows no availability")
                    
                    else:
                        logger.info("Could not determine availability from WSF website")
                
                except Exception as e:
                    logger.error(f"Error parsing WSF HTML: {e}")
                
                return sailings

            def send_discord_notification(self, ferry_config: dict, sailings: List[dict]):
                """Send Discord notification via webhook"""
                try:
                    embeds = []
                    
                    for sailing in sailings[:3]:  # Limit to 3 sailings
                        embed = {
                            "title": "üö¢ Ferry Availability Found!",
                            "color": 3447003,  # Blue color
                            "fields": [
                                {
                                    "name": "Route",
                                    "value": sailing['route'],
                                    "inline": True
                                },
                                {
                                    "name": "Date",
                                    "value": sailing['date'],
                                    "inline": True
                                },
                                {
                                    "name": "Departure",
                                    "value": sailing['departure_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Arrival",
                                    "value": sailing['arrival_time'],
                                    "inline": True
                                },
                                {
                                    "name": "Vessel",
                                    "value": sailing['vessel_name'],
                                    "inline": True
                                },
                                {
                                    "name": "Spaces Available",
                                    "value": str(sailing.get('spaces_available', 'Unknown')),
                                    "inline": True
                                }
                            ],
                            "footer": {
                                "text": f"Found at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                            },
                            "url": "https://secureapps.wsdot.wa.gov/Ferries/Reservations/Vehicle/"
                        }
                        embeds.append(embed)
                    
                    # Create message content
                    time_filter = ""
                    if ferry_config.get('sailing_time_from') or ferry_config.get('sailing_time_to'):
                        time_from = ferry_config.get('sailing_time_from', 'any time')
                        time_to = ferry_config.get('sailing_time_to', 'any time')
                        time_filter = f"\nüïê Time window: {time_from} - {time_to}"
                    
                    content = f"üéâ **Found {len(sailings)} ferry sailing(s) available!**{time_filter}"
                    
                    message = {
                        "content": content,
                        "embeds": embeds
                    }
                    
                    logger.info(f"Sending Discord notification for {len(sailings)} sailings...")
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Discord notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Discord notification failed: {response.status_code}")
                        logger.error(f"Response: {response.text}")
                        return False
                
                except Exception as e:
                    logger.error(f"‚ùå Error sending Discord notification: {e}")
                    return False

            def send_test_notification(self):
                """Send a test notification to verify Discord webhook works"""
                try:
                    message = {
                        "content": "üö¢ **Ferry Bot Test**\nBot is running and Discord webhook is working!\n‚è∞ Monitoring for ferry availability..."
                    }
                    
                    response = requests.post(self.discord_webhook_url, json=message, timeout=10)
                    
                    if response.status_code == 204:
                        logger.info("‚úÖ Test notification sent successfully!")
                        return True
                    else:
                        logger.error(f"‚ùå Test notification failed: {response.status_code}")
                        return False
                        
                except Exception as e:
                    logger.error(f"‚ùå Error sending test notification: {e}")
                    return False

            def run_ferry_check(self, ferry_configs: List[dict]):
                """Run ferry availability check"""
                logger.info(f"üöÄ Starting ferry bot at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC")
                
                # Send test notification first
                self.send_test_notification()
                
                total_found = 0
                
                for config in ferry_configs:
                    try:
                        logger.info(f"üîç Checking: {config['terminal_from']} ‚Üí {config['terminal_to']} on {config['sailing_date']}")
                        
                        sailings = self.check_wsf_website(config)
                        
                        if sailings:
                            total_found += len(sailings)
                            logger.info(f"üéâ Found {len(sailings)} available sailings!")
                            success = self.send_discord_notification(config, sailings)
                            if not success:
                                logger.warning("Discord notification failed, but continuing...")
                        else:
                            logger.info(f"üòû No availability found")
                        
                        # Small delay between checks
                        time.sleep(2)
                    
                    except Exception as e:
                        logger.error(f"‚ùå Error checking ferry: {e}")
                
                logger.info(f"‚úÖ Ferry check completed. Found {total_found} total available sailings.")

        def main():
            """Main function"""
            try:
                # Get configuration from environment variables
                discord_webhook_url = os.getenv('DISCORD_WEBHOOK_URL')
                wsdot_api_key = os.getenv('WSDOT_API_KEY', 'not-needed-for-now')
                ferry_config_str = os.getenv('FERRY_CONFIG')
                
                if not discord_webhook_url:
                    logger.error("‚ùå DISCORD_WEBHOOK_URL environment variable not set")
                    return
                
                if not ferry_config_str:
                    logger.error("‚ùå FERRY_CONFIG environment variable not set")
                    return
                
                # Parse ferry configuration
                import yaml
                ferry_configs_data = yaml.safe_load(ferry_config_str)
                
                if isinstance(ferry_configs_data, list):
                    ferry_configs = ferry_configs_data
                else:
                    ferry_configs = [ferry_configs_data]
                
                logger.info(f"üìù Loaded {len(ferry_configs)} ferry route(s) to monitor")
                
                # Create and run the bot
                bot = WorkingFerryBot(discord_webhook_url, wsdot_api_key)
                bot.run_ferry_check(ferry_configs)
                
            except Exception as e:
                logger.error(f"‚ùå Fatal error: {e}")
                # Try to send error notification
                try:
                    if 'discord_webhook_url' in locals():
                        error_msg = {
                            "content": f"‚ö†Ô∏è **Ferry Bot Error**\n```{str(e)}```\nTime: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"
                        }
                        requests.post(discord_webhook_url, json=error_msg, timeout=5)
                except:
                    pass

        if __name__ == "__main__":
            main()
        EOF
        
    - name: Run working ferry bot
      env:
        DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        WSDOT_API_KEY: ${{ secrets.WSDOT_API_KEY }}
        FERRY_CONFIG: ${{ secrets.FERRY_CONFIG }}
      run: |
        python working_ferry_bot.py
